{"version":3,"file":"index-B4cE5vkm.js","sources":["../../src/index.ts","../../demo/main.ts"],"sourcesContent":["const S4 = (): string => (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\nconst randomUUIDDumbPolyfill = (): string => `${S4()}${S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`;\nconst randomId = (): string => crypto.randomUUID?.() || randomUUIDDumbPolyfill();\n\n/**\n * Limit a number between 2 values, inclusive, order doesn't matter\n * @param {number} n1\n * @param {number} n2\n * @param {number} n3\n * @returns {number}\n */\nexport const clamp = (n1: number, n2: number = n1, n3: number = n2): number => {\n    const [min, num, max] = [n1, n2, n3].sort((a, b) => a - b);\n    return Math.min(max, Math.max(min, num));\n};\n\nconst dragObserver = new MutationObserver((mutationList, observer) => {\n    mutationList.forEach((mutation) => {\n        const src = mutation.target as HTMLElement;\n        if (!src.dataset) return; // Type guard\n        const target = document.getElementById(src.dataset.compId || src.dataset.wireId || '') as HTMLElement | null;\n\n        if (!target) {\n            observer.disconnect();\n            return;\n        }\n\n        target.style.top = src.style.top;\n        target.style.left = src.style.left;\n        target.style.width = src.style.width;\n        target.style.height = src.style.height;\n    });\n});\n\n/**\n * Create wireframes\n * We create a separate wireframe layer for each offset-parent of the collected elements\n * This way we don't need to worry about observing document layout changes (at least theoretically)\n * @param {HTMLElement[] | NodeListOf<HTMLElement> | string} elementsListOrSelector A list of elements or a selector\n * @returns {HTMLElement[]}\n */\nexport function createDocumentWireframe(elementsListOrSelector: HTMLElement[] | NodeListOf<HTMLElement> | string): HTMLElement[] {\n    // Item template\n    const itemLayer = document.createElement('div');\n    itemLayer.className = 'wireframe-layer';\n\n    // Layer template\n    const item = document.createElement('div');\n    item.className = 'wireframe-layer-item';\n\n    // Collect elements\n    const elements: HTMLElement[] = [\n        ...(typeof elementsListOrSelector === 'string'\n            ? (document.querySelectorAll(elementsListOrSelector) as NodeListOf<HTMLElement>) || []\n            : elementsListOrSelector),\n    ];\n\n    // Create wires\n    const wires = elements.map((element) => {\n        const wire = item.cloneNode() as HTMLElement;\n        const parent = element.parentNode as HTMLElement | null;\n        if (!parent) throw new Error('Element must have a parent node');\n\n        // Get or Create a layer\n        const layer = (parent.querySelector('.wireframe-layer') || itemLayer.cloneNode()) as HTMLElement;\n\n        // No IDs? create unique ones\n        layer.id = layer.id || `wireframe-layer-${randomId()}`;\n        element.id = element.id || `comp-${randomId()}`;\n\n        const id = element.id;\n        const wireId = `wire-${id}`;\n\n        // Set element id, corresponding wire id and initial element position and size\n        element.dataset.wireId = wireId;\n\n        element.style.position = 'absolute'; // Ensure positioning context\n        element.style.top = `${element.offsetTop}px`;\n        element.style.left = `${element.offsetLeft}px`;\n        element.style.width = `${element.offsetWidth}px`;\n        element.style.height = `${element.offsetHeight}px`;\n\n        // Set wire id, corresponding element id and initial wire position and size\n        wire.id = wireId;\n        wire.dataset.compId = id;\n\n        wire.style.position = 'absolute'; // Ensure positioning context for wireframe\n        wire.style.top = element.style.top;\n        wire.style.left = element.style.left;\n        wire.style.width = element.style.width;\n        wire.style.height = element.style.height;\n\n        // Add wire to layer\n        layer.appendChild(wire);\n\n        // Add layer to parent if needed\n        if (!parent.contains(layer)) {\n            parent.appendChild(layer);\n        }\n\n        // If element style changes update wire\n        dragObserver.observe(element, {\n            attributes: true,\n            attributeFilter: ['style'],\n        });\n\n        // IF wire style changes update element\n        dragObserver.observe(wire, {\n            attributes: true,\n            attributeFilter: ['style'],\n        });\n\n        return wire;\n    });\n\n    return wires;\n}\n\nexport type ResizeHandleType = 'all' | 'sides' | 'corners' | 'corners-aspect';\n\nexport interface MakeWireframeResizableOptions extends ResizableBoxOptions {\n    resize?: ResizeHandleType;\n    container?: string; // container element ID\n}\n\n/**\n * Make a wireframe element resizable\n * @param {HTMLElement|string} wireElementOrId the wireframe box to resize\n * @param {MakeWireframeResizableOptions} options\n */\nexport function makeWireframeElementResizable(\n    wireElementOrId: HTMLElement | string,\n    {\n        resize = 'all',\n        container,\n        ...rest // Captures ResizableBoxOptions\n    }: MakeWireframeResizableOptions = {}\n): void {\n    const wire = typeof wireElementOrId === 'string' ? document.getElementById(wireElementOrId) : wireElementOrId;\n\n    if (!wire || !(wire instanceof HTMLElement) || !wire.dataset.compId) {\n        throw new Error(`${wireElementOrId} is not a valid wireframe element or ID`);\n    }\n\n    const element = document.getElementById(wire.dataset.compId);\n    if (!element) {\n        throw new Error(`Could not find original element with ID: ${wire.dataset.compId}`);\n    }\n    element.style.position = 'absolute';\n\n    wire.dataset.resizable = 'resizable';\n\n    if (container) {\n        wire.dataset.resizableContainer = container;\n    }\n\n    // Clear existing handles before adding new ones\n    wire.innerHTML = '';\n\n    if (['all', 'sides'].includes(resize)) {\n        wire.innerHTML += `\n<div class=\"resizable-box-handle\" data-handle=\"top\"></div>\n<div class=\"resizable-box-handle\" data-handle=\"right\"></div>\n<div class=\"resizable-box-handle\" data-handle=\"bottom\"></div>\n<div class=\"resizable-box-handle\" data-handle=\"left\"></div>`;\n    }\n\n    if (['all', 'corners', 'corners-aspect'].includes(resize)) {\n        wire.innerHTML += `\n<div class=\"resizable-box-handle\" data-handle=\"top-left\"></div>\n<div class=\"resizable-box-handle\" data-handle=\"top-right\"></div>\n<div class=\"resizable-box-handle\" data-handle=\"bottom-left\"></div>\n<div class=\"resizable-box-handle\" data-handle=\"bottom-right\"></div>`;\n    }\n\n    if (resize === 'corners-aspect') {\n        wire.dataset.resizableAspect = 'keep';\n    }\n\n    setResizableBoxEvents(wire, rest);\n}\n\n\nexport interface ResizableBoxOptions {\n    minWidth?: number;\n    minHeight?: number;\n    maxWidth?: number;\n    maxHeight?: number;\n    onStart?: (e: PointerEvent) => void;\n    onMove?: (e: PointerEvent) => void;\n    onEnd?: (e: PointerEvent) => void;\n}\n\ninterface Rects {\n    container: DOMRect;\n    parent: DOMRect;\n    initial: { top: number; left: number; width: number; height: number };\n    diff: { left: number; top: number };\n    start: { left: number; top: number };\n    min: { width: number; height: number };\n    max: { width: number; height: number };\n}\n\n/**\n * Sets up pointer events for resizing and dragging a box element.\n * Expects a specific HTML structure with optional handles.\n * @param {HTMLElement} box The element to make resizable/draggable.\n * @param {ResizableBoxOptions} options Configuration options.\n */\nexport function setResizableBoxEvents(\n    box: HTMLElement,\n    { minWidth = 10, minHeight = 10, maxWidth, maxHeight, onStart, onMove, onEnd }: ResizableBoxOptions = {}\n): void {\n    const container = document.getElementById(box.dataset.resizableContainer || '') || document.body;\n\n    //TODO - implement aspect ratio locking\n    const keepAspect = box.dataset.resizableAspect === 'keep';\n    const initialAspectRatio = keepAspect ? box.offsetWidth / box.offsetHeight : 0;\n\n    maxWidth = maxWidth ?? container.offsetWidth;\n    maxHeight = maxHeight ?? container.offsetHeight;\n\n    // Include the box itself for dragging\n    const handles: HTMLElement[] = [...box.querySelectorAll<HTMLElement>('[data-handle]'), box];\n    const parent = box.offsetParent as HTMLElement | null;\n\n    if (!parent || !container.contains(parent)) {\n        console.error('Resizable box must have an offsetParent contained within the specified container or document.body');\n        return;\n    }\n\n    // Initialize rects structure with proper types\n    const rects: Rects = {\n        container: {} as DOMRect,\n        parent: {} as DOMRect,\n        initial: { top: 0, left: 0, width: 0, height: 0 },\n        diff: { left: 0, top: 0 },\n        start: { left: 0, top: 0 },\n        min: { width: minWidth, height: minHeight }, // Use provided min values\n        max: { width: maxWidth, height: maxHeight }, // Use resolved max values\n    };\n\n    handles.forEach((handle) => {\n        handle.addEventListener(\n            'pointerdown',\n            (event: PointerEvent) => {\n                // Ensure event target is an HTMLElement with dataset\n                const target = event.target as HTMLElement;\n                if (!target || !target.dataset) return;\n\n                event.preventDefault(); // Prevent default actions like text selection\n                event.stopPropagation(); // Prevent triggering other listeners (e.g., if nested)\n\n                rects.container = container.getBoundingClientRect();\n                rects.parent = parent.getBoundingClientRect();\n                rects.initial = {\n                    top: box.offsetTop,\n                    left: box.offsetLeft,\n                    width: box.offsetWidth,\n                    height: box.offsetHeight,\n                };\n                rects.diff = {\n                    left: rects.parent.left - rects.container.left,\n                    top: rects.parent.top - rects.container.top,\n                };\n                rects.start = {\n                    // Use pointer position relative to the document\n                    left: event.clientX,\n                    top: event.clientY,\n                };\n\n                const corner = target.dataset.handle || ''; // Empty string means dragging the box itself\n                const handleMove = moveBox.bind(null, box, corner, rects, onMove, keepAspect, initialAspectRatio);\n\n                container.dataset.draggingWithin = 'true';\n                box.dataset.dragging = 'true';\n                box.style.willChange = 'top, left, width, height'; // Performance hint\n\n                onStart?.(event);\n\n                container.setPointerCapture(event.pointerId);\n                container.addEventListener('pointermove', handleMove);\n\n                const handlePointerUp = (e: PointerEvent) => {\n                    // Check if it's the same pointer that started the drag\n                    if (e.pointerId !== event.pointerId) return;\n\n                    e.preventDefault();\n                    delete container.dataset.draggingWithin;\n                    delete box.dataset.dragging;\n                    box.style.willChange = 'auto';\n\n                    container.releasePointerCapture(event.pointerId);\n                    container.removeEventListener('pointermove', handleMove);\n                    container.removeEventListener('pointerup', handlePointerUp); // Remove this specific listener\n\n                    onEnd?.(e);\n                };\n\n                container.addEventListener('pointerup', handlePointerUp);\n            },\n            { capture: true } // Use capture phase to catch events early\n        );\n    });\n}\n\nfunction moveBox(\n    box: HTMLElement,\n    corner: string,\n    rects: Rects,\n    onMove: ((e: PointerEvent) => void) | undefined,\n    keepAspect: boolean,\n    aspectRatio: number,\n    event: PointerEvent\n): void {\n    // Use pointer position relative to the document (clientX/clientY)\n    const currentX = event.clientX;\n    const currentY = event.clientY;\n    const deltaX = currentX - rects.start.left;\n    const deltaY = currentY - rects.start.top;\n\n    let { top, left, width, height } = { ...rects.initial }; // Work with copies\n\n    event.preventDefault();\n\n    // Calculate new dimensions/position based on the corner being dragged\n    if (corner.includes('top')) {\n        top = rects.initial.top + deltaY;\n        height = rects.initial.height - deltaY;\n    } else if (corner.includes('bottom')) {\n        height = rects.initial.height + deltaY;\n    }\n\n    if (corner.includes('left')) {\n        left = rects.initial.left + deltaX;\n        width = rects.initial.width - deltaX;\n    } else if (corner.includes('right')) {\n        width = rects.initial.width + deltaX;\n    }\n\n    // Dragging the box itself (no corner)\n    if (!corner) {\n        top = rects.initial.top + deltaY;\n        left = rects.initial.left + deltaX;\n    }\n\n    // --- Aspect Ratio Lock (Basic Implementation) ---\n    // TODO: Refine aspect ratio logic, especially when dragging corners\n    if (keepAspect && corner) {\n        if (corner.includes('left') || corner.includes('right')) {\n            // Adjust height based on width change\n            const newHeight = width / aspectRatio;\n            if (corner.includes('top')) {\n                top -= (newHeight - height); // Adjust top to maintain bottom position\n            }\n            height = newHeight;\n        } else if (corner.includes('top') || corner.includes('bottom')) {\n            // Adjust width based on height change\n            const newWidth = height * aspectRatio;\n             if (corner.includes('left')) {\n                left -= (newWidth - width); // Adjust left to maintain right position\n            }\n            width = newWidth;\n        }\n    }\n    // --- End Aspect Ratio ---\n\n    // Clamp dimensions to min/max values\n    width = clamp(rects.min.width, rects.max.width, width);\n    height = clamp(rects.min.height, rects.max.height, height);\n\n    // Adjust position if dimensions were clamped during resize\n    if (corner.includes('top') && height !== rects.initial.height - deltaY) {\n        top = rects.initial.top + rects.initial.height - height;\n    }\n    if (corner.includes('left') && width !== rects.initial.width - deltaX) {\n        left = rects.initial.left + rects.initial.width - width;\n    }\n\n    // Clamp position within the container boundaries\n    const clampedTop = clamp(\n        -rects.diff.top, // Minimum top relative to parent\n        rects.container.height - rects.diff.top - height, // Maximum top relative to parent\n        top\n    );\n    const clampedLeft = clamp(\n        -rects.diff.left, // Minimum left relative to parent\n        rects.container.width - rects.diff.left - width, // Maximum left relative to parent\n        left\n    );\n\n    // Apply styles\n    box.style.top = `${clampedTop}px`;\n    box.style.left = `${clampedLeft}px`;\n    box.style.width = `${width}px`;\n    box.style.height = `${height}px`;\n\n    onMove?.(event);\n}\n","import { setResizableBoxEvents, createDocumentWireframe, makeWireframeElementResizable } from '@/index';\nimport '@/index.css';\nimport './style.css';\n\nfunction init() {\n    const box1 = document.getElementById('box1') as HTMLElement | null;\n    const box2 = document.getElementById('box2') as HTMLElement | null;\n    const box3 = document.getElementById('box3') as HTMLElement | null;\n    const stage = document.getElementById('stage') as HTMLElement | null;\n\n    if (!box1 || !box2 || !box3 || !stage) {\n        console.error(\"Demo elements not found!\");\n        return;\n    }\n\n    const [wire1, wire2] = createDocumentWireframe([box1, box2]);\n\n    makeWireframeElementResizable(wire1, {\n        resize: 'all',\n        onStart: () => console.log('Wire1 Start'),\n        onMove: () => console.log('Wire1 Move'),\n        onEnd: () => console.log('Wire1 End'),\n    });\n\n    makeWireframeElementResizable(wire2, {\n        container: 'stage',\n        resize: 'corners',\n        minWidth: 50,\n        minHeight: 50,\n        maxWidth: stage.offsetWidth - 20,\n        maxHeight: stage.offsetHeight - 20,\n    });\n\n    setResizableBoxEvents(box3, {\n        minWidth: 100,\n        minHeight: 50,\n        onStart: () => console.log('Box3 Start'),\n        onMove: () => console.log('Box3 Move'),\n        onEnd: () => console.log('Box3 End'),\n    });\n}\n\n/**\n * Run init() after the DOM is fully loaded.\n */\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', init);\n} else {\n    init();\n}\n"],"names":["S4","randomUUIDDumbPolyfill","randomId","_a","clamp","n1","n2","n3","min","num","max","a","b","dragObserver","mutationList","observer","mutation","src","target","createDocumentWireframe","elementsListOrSelector","itemLayer","item","element","wire","parent","layer","id","wireId","makeWireframeElementResizable","wireElementOrId","resize","container","rest","setResizableBoxEvents","box","minWidth","minHeight","maxWidth","maxHeight","onStart","onMove","onEnd","keepAspect","initialAspectRatio","handles","rects","handle","event","corner","handleMove","moveBox","handlePointerUp","e","aspectRatio","currentX","currentY","deltaX","deltaY","top","left","width","height","newHeight","newWidth","clampedTop","clampedLeft","init","box1","box2","box3","stage","wire1","wire2"],"mappings":"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"}