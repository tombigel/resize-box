{"version":3,"file":"index-DihRYtUw.js","sources":["../../src/index.ts","../../demo/main.ts"],"sourcesContent":["const S4 = (): string => (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\nconst randomUUIDDumbPolyfill = (): string => `${S4()}${S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`;\nconst randomId = (): string => crypto.randomUUID?.() || randomUUIDDumbPolyfill();\n\n/**\n * Limit a number between 2 values, inclusive, order doesn't matter\n * @param {number} n1\n * @param {number} n2\n * @param {number} n3\n * @returns {number}\n */\nexport const clamp = (n1: number, n2: number = n1, n3: number = n2): number => {\n    const [min, num, max] = [n1, n2, n3].sort((a, b) => a - b);\n    return Math.min(max, Math.max(min, num));\n};\n\nconst dragObserver = new MutationObserver((mutationList, observer) => {\n    mutationList.forEach((mutation) => {\n        const src = mutation.target as HTMLElement;\n        if (!src.dataset) return; // Type guard\n        const target = document.getElementById(src.dataset.compId || src.dataset.wireId || '') as HTMLElement | null;\n\n        if (!target) {\n            observer.disconnect();\n            return;\n        }\n\n        target.style.top = src.style.top;\n        target.style.left = src.style.left;\n        target.style.width = src.style.width;\n        target.style.height = src.style.height;\n    });\n});\n\n/**\n * Create wireframes\n * We create a separate wireframe layer for each offset-parent of the collected elements\n * This way we don't need to worry about observing document layout changes (at least theoretically)\n * @param {HTMLElement[] | NodeListOf<HTMLElement> | string} elementsListOrSelector A list of elements or a selector\n * @returns {HTMLElement[]}\n */\nexport function createDocumentWireframe(elementsListOrSelector: HTMLElement[] | NodeListOf<HTMLElement> | string): HTMLElement[] {\n    // Item template\n    const itemLayer = document.createElement('div');\n    itemLayer.className = 'wireframe-layer';\n\n    // Layer template\n    const item = document.createElement('div');\n    item.className = 'wireframe-layer-item';\n\n    // Collect elements\n    const elements: HTMLElement[] = [\n        ...(typeof elementsListOrSelector === 'string'\n            ? (document.querySelectorAll(elementsListOrSelector) as NodeListOf<HTMLElement>) || []\n            : elementsListOrSelector),\n    ];\n\n    // Create wires\n    const wires = elements.map((element) => {\n        const wire = item.cloneNode() as HTMLElement;\n        const parent = element.parentNode as HTMLElement | null;\n        if (!parent) throw new Error('Element must have a parent node');\n\n        // Get or Create a layer\n        const layer = (parent.querySelector('.wireframe-layer') || itemLayer.cloneNode()) as HTMLElement;\n\n        // No IDs? create unique ones\n        layer.id = layer.id || `wireframe-layer-${randomId()}`;\n        element.id = element.id || `comp-${randomId()}`;\n\n        const id = element.id;\n        const wireId = `wire-${id}`;\n\n        // Set element id, corresponding wire id and initial element position and size\n        element.dataset.wireId = wireId;\n\n        element.style.position = 'absolute'; // Ensure positioning context\n        element.style.top = `${element.offsetTop}px`;\n        element.style.left = `${element.offsetLeft}px`;\n        element.style.width = `${element.offsetWidth}px`;\n        element.style.height = `${element.offsetHeight}px`;\n\n        // Set wire id, corresponding element id and initial wire position and size\n        wire.id = wireId;\n        wire.dataset.compId = id;\n\n        wire.style.position = 'absolute'; // Ensure positioning context for wireframe\n        wire.style.top = element.style.top;\n        wire.style.left = element.style.left;\n        wire.style.width = element.style.width;\n        wire.style.height = element.style.height;\n\n        // Add wire to layer\n        layer.appendChild(wire);\n\n        // Add layer to parent if needed\n        if (!parent.contains(layer)) {\n            parent.appendChild(layer);\n        }\n\n        // If element style changes update wire\n        dragObserver.observe(element, {\n            attributes: true,\n            attributeFilter: ['style'],\n        });\n\n        // IF wire style changes update element\n        dragObserver.observe(wire, {\n            attributes: true,\n            attributeFilter: ['style'],\n        });\n\n        return wire;\n    });\n\n    return wires;\n}\n\nexport type HandleName = 'top' | 'left' | 'bottom' | 'right' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\nexport type ResizeHandlesOption = 'all' | 'sides' | 'corners' | 'none' | HandleName[];\n\nexport interface MakeWireframeResizableOptions extends ResizableBoxOptions {\n    handles?: ResizeHandlesOption;\n    keepAspectRatio?: boolean;\n    container?: string;\n}\n\n/**\n * Make a wireframe element resizable\n * @param {HTMLElement|string} wireElementOrId the wireframe box to resize\n * @param {MakeWireframeResizableOptions} options\n */\nexport function makeWireframeElementResizable(\n    wireElementOrId: HTMLElement | string,\n    {\n        handles = 'all',\n        container,\n        keepAspectRatio = false,\n        ...rest // Captures ResizableBoxOptions (including draggable)\n    }: MakeWireframeResizableOptions = {}\n): void {\n    const wire = typeof wireElementOrId === 'string' ? document.getElementById(wireElementOrId) : wireElementOrId;\n\n    if (!wire || !(wire instanceof HTMLElement) || !wire.dataset.compId) {\n        throw new Error(`${wireElementOrId} is not a valid wireframe element or ID`);\n    }\n\n    const element = document.getElementById(wire.dataset.compId);\n    if (!element) {\n        throw new Error(`Could not find original element with ID: ${wire.dataset.compId}`);\n    }\n    element.style.position = 'absolute';\n\n    wire.dataset.resizable = 'resizable';\n\n    if (container) {\n        wire.dataset.resizableContainer = container;\n    }\n\n    wire.innerHTML = '';\n\n    let handlesToAdd: HandleName[] = [];\n    const allSides: HandleName[] = ['top', 'right', 'bottom', 'left'];\n    const allCorners: HandleName[] = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\n\n    if (handles === 'all') {\n        handlesToAdd = [...allSides, ...allCorners];\n    } else if (handles === 'sides') {\n        handlesToAdd = [...allSides];\n    } else if (handles === 'corners') {\n        handlesToAdd = [...allCorners];\n    } else if (Array.isArray(handles)) {\n        handlesToAdd = handles;\n    } // 'none' or other invalid string results in no handles\n\n    handlesToAdd.forEach(handleName => {\n        wire.innerHTML += `<div class=\"resizable-box-handle\" data-handle=\"${handleName}\"></div>`;\n    });\n\n    if (keepAspectRatio) {\n        wire.dataset.resizableAspect = 'keep';\n    } else {\n        delete wire.dataset.resizableAspect;\n    }\n\n    setResizableBoxEvents(wire, { keepAspectRatio, ...rest });\n}\n\nexport interface ResizableBoxOptions {\n    minWidth?: number;\n    minHeight?: number;\n    maxWidth?: number;\n    maxHeight?: number;\n    draggable?: boolean;\n    keepAspectRatio?: boolean;\n    invertOnContainerEdge?: boolean;\n    onStart?: (e: PointerEvent) => void;\n    onMove?: (e: PointerEvent) => void;\n    onEnd?: (e: PointerEvent) => void;\n}\n\ninterface Rects {\n    container: DOMRect;\n    parent: DOMRect;\n    initial: { top: number; left: number; width: number; height: number };\n    diff: { left: number; top: number };\n    start: { left: number; top: number };\n    min: { width: number; height: number };\n    max: { width: number; height: number };\n}\n\n/**\n * Sets up pointer events for resizing and dragging a box element.\n * Expects a specific HTML structure with optional handles.\n * @param {HTMLElement} box The element to make resizable/draggable.\n * @param {ResizableBoxOptions} options Configuration options.\n */\nexport function setResizableBoxEvents(\n    box: HTMLElement,\n    {\n        minWidth = 10,\n        minHeight = 10,\n        maxWidth,\n        maxHeight,\n        draggable = true,\n        keepAspectRatio = false,\n        invertOnContainerEdge = false,\n        onStart,\n        onMove,\n        onEnd\n    }: ResizableBoxOptions = {}\n): void {\n    const container = document.getElementById(box.dataset.resizableContainer || '') || document.body;\n\n    // Set data attribute based on draggable option for CSS cursor styling\n    if (!draggable) {\n        box.dataset.resizableDraggable = 'false';\n    } else {\n        // Ensure attribute is removed if it was set previously and draggable is now true\n        delete box.dataset.resizableDraggable;\n    }\n\n    // Set data attribute for inversion behavior\n    if (invertOnContainerEdge) {\n        box.dataset.resizableInvert = 'invert';\n    } else {\n        delete box.dataset.resizableInvert;\n    }\n\n    // Aspect ratio check (reads from option OR data attribute)\n    const shouldKeepAspect = keepAspectRatio || box.dataset.resizableAspect === 'keep';\n    const initialAspectRatio = shouldKeepAspect ? box.offsetWidth / box.offsetHeight : 0;\n\n    maxWidth = maxWidth ?? container.offsetWidth;\n    maxHeight = maxHeight ?? container.offsetHeight;\n\n    // Conditionally include the box for dragging\n    const handleElements: HTMLElement[] = [...box.querySelectorAll<HTMLElement>('[data-handle]')];\n    if (draggable) {\n        handleElements.push(box);\n    }\n\n    const parent = box.offsetParent as HTMLElement | null;\n\n    if (!parent || !container.contains(parent)) {\n        console.error('Resizable box must have an offsetParent contained within the specified container or document.body');\n        return;\n    }\n\n    // Initialize rects structure with proper types\n    const rects: Rects = {\n        container: {} as DOMRect,\n        parent: {} as DOMRect,\n        initial: { top: 0, left: 0, width: 0, height: 0 },\n        diff: { left: 0, top: 0 },\n        start: { left: 0, top: 0 },\n        min: { width: minWidth, height: minHeight }, // Use provided min values\n        max: { width: maxWidth, height: maxHeight }, // Use resolved max values\n    };\n\n    handleElements.forEach((handle) => {\n        handle.addEventListener(\n            'pointerdown',\n            (event: PointerEvent) => {\n                // Ensure event target is an HTMLElement with dataset\n                const target = event.target as HTMLElement;\n                if (!target || !target.dataset) return;\n\n                event.preventDefault(); // Prevent default actions like text selection\n                event.stopPropagation(); // Prevent triggering other listeners (e.g., if nested)\n\n                rects.container = container.getBoundingClientRect();\n                rects.parent = parent.getBoundingClientRect();\n                rects.initial = {\n                    top: box.offsetTop,\n                    left: box.offsetLeft,\n                    width: box.offsetWidth,\n                    height: box.offsetHeight,\n                };\n                rects.diff = {\n                    left: rects.parent.left - rects.container.left,\n                    top: rects.parent.top - rects.container.top,\n                };\n                rects.start = {\n                    // Use pointer position relative to the document\n                    left: event.clientX,\n                    top: event.clientY,\n                };\n\n                const corner = target.dataset.handle || ''; // Empty string means dragging the box itself\n                // Pass aspect ratio info and edge behavior option to moveBox\n                const handleMove = moveBox.bind(null, box, corner, rects, onMove, shouldKeepAspect, initialAspectRatio, invertOnContainerEdge);\n\n                container.dataset.draggingWithin = 'true';\n                box.dataset.dragging = 'true';\n                box.style.willChange = 'top, left, width, height'; // Performance hint\n\n                onStart?.(event);\n\n                container.setPointerCapture(event.pointerId);\n                container.addEventListener('pointermove', handleMove);\n\n                const handlePointerUp = (e: PointerEvent) => {\n                    // Check if it's the same pointer that started the drag\n                    if (e.pointerId !== event.pointerId) return;\n\n                    e.preventDefault();\n                    delete container.dataset.draggingWithin;\n                    delete box.dataset.dragging;\n                    box.style.willChange = 'auto';\n\n                    container.releasePointerCapture(event.pointerId);\n                    container.removeEventListener('pointermove', handleMove);\n                    container.removeEventListener('pointerup', handlePointerUp); // Remove this specific listener\n\n                    onEnd?.(e);\n                };\n\n                container.addEventListener('pointerup', handlePointerUp);\n            },\n            { capture: true } // Use capture phase to catch events early\n        );\n    });\n}\n\nfunction moveBox(\n    box: HTMLElement,\n    corner: string,\n    rects: Rects,\n    onMove: ((e: PointerEvent) => void) | undefined,\n    shouldKeepAspect: boolean,\n    aspectRatio: number,\n    invertOnContainerEdge: boolean,\n    event: PointerEvent\n): void {\n    // Use pointer position relative to the document (clientX/clientY)\n    const currentX = event.clientX;\n    const currentY = event.clientY;\n\n    const startLeft = typeof rects.start.left === 'number' ? rects.start.left : currentX;\n    const startTop = typeof rects.start.top === 'number' ? rects.start.top : currentY;\n    // Use let instead of const for delta values\n    let deltaX = currentX - startLeft;\n    let deltaY = currentY - startTop;\n\n    let { top, left, width, height } = { ...rects.initial }; // Work with copies\n\n    event.preventDefault();\n\n    // --- Optional: Clamp Delta based on Container Edges ---\n    if (!invertOnContainerEdge && corner) {\n        // Available space from the box edges to the container edges\n        // Note: rects.diff accounts for the offsetParent's position relative to the container\n        const spaceLeft = rects.initial.left + rects.diff.left;\n        const spaceRight = rects.container.width - (rects.initial.left + rects.initial.width + rects.diff.left);\n        const spaceTop = rects.initial.top + rects.diff.top;\n        const spaceBottom = rects.container.height - (rects.initial.top + rects.initial.height + rects.diff.top);\n\n        if (corner.includes('left')) {\n            // Limit how far left the pointer can go (negative deltaX)\n            deltaX = Math.max(deltaX, -spaceLeft);\n        }\n        if (corner.includes('right')) {\n            // Limit how far right the pointer can go (positive deltaX)\n            deltaX = Math.min(deltaX, spaceRight);\n        }\n        if (corner.includes('top')) {\n            // Limit how far up the pointer can go (negative deltaY)\n            deltaY = Math.max(deltaY, -spaceTop);\n        }\n        if (corner.includes('bottom')) {\n            // Limit how far down the pointer can go (positive deltaY)\n            deltaY = Math.min(deltaY, spaceBottom);\n        }\n    }\n    // --- End Delta Clamping ---\n\n    // Calculate new dimensions/position based on the (potentially clamped) delta\n    if (corner.includes('top')) {\n        top = rects.initial.top + deltaY;\n        height = rects.initial.height - deltaY;\n    } else if (corner.includes('bottom')) {\n        height = rects.initial.height + deltaY;\n    }\n\n    if (corner.includes('left')) {\n        left = rects.initial.left + deltaX;\n        width = rects.initial.width - deltaX;\n    } else if (corner.includes('right')) {\n        width = rects.initial.width + deltaX;\n    }\n\n    // Dragging the box itself (no corner)\n    if (!corner) {\n        top = rects.initial.top + deltaY;\n        left = rects.initial.left + deltaX;\n    }\n\n    // --- Aspect Ratio Lock (Basic Implementation) ---\n    // TODO: Refine aspect ratio logic, especially when dragging corners\n    if (shouldKeepAspect && corner) {\n        if (corner.includes('left') || corner.includes('right')) {\n            // Adjust height based on width change\n            const newHeight = width / aspectRatio;\n            if (corner.includes('top')) {\n                top -= (newHeight - height); // Adjust top to maintain bottom position\n            }\n            height = newHeight;\n        } else if (corner.includes('top') || corner.includes('bottom')) {\n            // Adjust width based on height change\n            const newWidth = height * aspectRatio;\n             if (corner.includes('left')) {\n                left -= (newWidth - width); // Adjust left to maintain right position\n            }\n            width = newWidth;\n        }\n    }\n    // --- End Aspect Ratio ---\n\n    // --- Final Clamping ---\n    // 1. Clamp dimensions to min/max *options*\n    let clampedWidth = clamp(rects.min.width, rects.max.width, width);\n    let clampedHeight = clamp(rects.min.height, rects.max.height, height);\n\n    // 2. If aspect ratio locked, ensure clamped dimensions still respect it\n    //    (adjust the dimension that changed *less* proportionally)\n    if (shouldKeepAspect && corner) {\n         const widthRatio = clampedWidth / width; // Proportion of original width remaining after clamp (<=1)\n         const heightRatio = clampedHeight / height; // Proportion of original height remaining after clamp (<=1)\n\n         // Determine which dimension was clamped *more* (smaller ratio means more clamping)\n         if (widthRatio <= heightRatio) {\n             // Width was clamped more (or equally), adjust height based on clamped width\n             clampedHeight = clampedWidth / aspectRatio;\n         } else {\n             // Height was clamped more, adjust width based on clamped height\n             clampedWidth = clampedHeight * aspectRatio;\n         }\n\n         // Re-clamp *both* dimensions after aspect ratio adjustment,\n         // as the secondary adjustment might have pushed the other dimension beyond its limits.\n         clampedWidth = clamp(rects.min.width, rects.max.width, clampedWidth);\n         clampedHeight = clamp(rects.min.height, rects.max.height, clampedHeight);\n\n         // Final check: Ensure the *most* constrained dimension dictates the final size\n         // If clamping happened again, the aspect ratio might be slightly off.\n         // Recalculate the *other* dimension based on the most recent clamped values.\n         const finalWidthBasedOnHeight = clampedHeight * aspectRatio;\n         const finalHeightBasedOnWidth = clampedWidth / aspectRatio;\n\n        // If the current clamped width is smaller than what the clamped height suggests,\n        // it means width is the limiting factor. Adjust height accordingly.\n         if (clampedWidth < finalWidthBasedOnHeight - 0.001) { // Tolerance for floating point\n             clampedHeight = finalHeightBasedOnWidth;\n         }\n         // Otherwise, height is the limiting factor (or they match). Adjust width accordingly.\n         else {\n              clampedWidth = finalWidthBasedOnHeight;\n         }\n\n         // One final clamp as a safety net (values shouldn't change ideally)\n         clampedWidth = clamp(rects.min.width, rects.max.width, clampedWidth);\n         clampedHeight = clamp(rects.min.height, rects.max.height, clampedHeight);\n    }\n\n    // 3. Adjust position if dimensions were clamped during resize\n    //    (Ensure the edge opposite the dragged handle stays put)\n    //    Run this *before* clamping position\n    if (corner.includes('top') && clampedHeight !== height) {\n        top = rects.initial.top + rects.initial.height - clampedHeight;\n    }\n    if (corner.includes('left') && clampedWidth !== width) {\n        left = rects.initial.left + rects.initial.width - clampedWidth;\n    }\n     // Recalculate drag position if aspect ratio/clamping changed dimensions\n     if (!corner) {\n         top = rects.initial.top + deltaY;\n         left = rects.initial.left + deltaX;\n     }\n\n    // 4. Clamp position within the container boundaries *using clamped dimensions*\n    const clampedTop = clamp(\n        -rects.diff.top, // Min top relative to parent\n        rects.container.height - rects.diff.top - clampedHeight, // Max top relative to parent\n        top\n    );\n    const clampedLeft = clamp(\n        -rects.diff.left, // Min left relative to parent\n        rects.container.width - rects.diff.left - clampedWidth, // Max left relative to parent\n        left\n    );\n    // --- End Final Clamping ---\n\n    // Apply styles\n    box.style.top = `${clampedTop}px`;\n    box.style.left = `${clampedLeft}px`;\n    box.style.width = `${clampedWidth}px`;\n    box.style.height = `${clampedHeight}px`;\n\n    onMove?.(event);\n}\n","import { setResizableBoxEvents, createDocumentWireframe, makeWireframeElementResizable } from '@/index';\nimport '@/index.css';\nimport './style.css';\n\n// Renamed original init function\nfunction initResizableBoxes() {\n    const box1 = document.getElementById('box1') as HTMLElement | null;\n    const box2 = document.getElementById('box2') as HTMLElement | null;\n    const box3 = document.getElementById('box3') as HTMLElement | null;\n    const stage = document.getElementById('stage') as HTMLElement | null;\n    const box4 = document.getElementById('box4') as HTMLElement | null;\n    const box5 = document.getElementById('box5') as HTMLElement | null;\n    const box6 = document.getElementById('box6') as HTMLElement | null;\n\n    if (!box1 || !box2 || !box3 || !box4 || !box5 || !box6 || !stage) {\n        console.error(\"Demo elements not found!\");\n        return;\n    }\n\n    const [wire1, wire2, wire4, wire5, wire6] = createDocumentWireframe([box1, box2, box4, box5, box6]);\n\n    makeWireframeElementResizable(wire1, {\n        handles: 'all',\n        draggable: true,\n        onStart: () => console.log('Wire1 Start'),\n        onMove: () => console.log('Wire1 Move'),\n        onEnd: () => console.log('Wire1 End'),\n        invertOnContainerEdge: true,\n    });\n\n    makeWireframeElementResizable(wire2, {\n        container: 'stage',\n        handles: 'corners',\n        draggable: false,\n        invertOnContainerEdge: false,\n        minWidth: 50,\n        minHeight: 50,\n        maxWidth: stage.offsetWidth,\n        maxHeight: stage.offsetHeight,\n    });\n\n    setResizableBoxEvents(box3, {\n        draggable: true,\n        keepAspectRatio: false,\n        minWidth: 100,\n        minHeight: 50,\n        onStart: () => console.log('Box3 Start'),\n        onMove: () => console.log('Box3 Move'),\n        onEnd: () => console.log('Box3 End'),\n    });\n\n    makeWireframeElementResizable(wire4, {\n        container: 'stage',\n        handles: 'none',\n        draggable: true,\n    });\n\n    makeWireframeElementResizable(wire5, {\n        container: 'stage',\n        handles: ['top-left', 'bottom-right'],\n        draggable: false,\n        keepAspectRatio: true,\n        minWidth: 40,\n        minHeight: 40,\n    });\n\n    makeWireframeElementResizable(wire6, {\n        container: 'stage',\n        handles: 'all',\n        draggable: true,\n        invertOnContainerEdge: true,\n    });\n}\n\n/**\n * Run init() after the DOM is fully loaded.\n */\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', initResizableBoxes);\n} else {\n    initResizableBoxes();\n}\n"],"names":["S4","randomUUIDDumbPolyfill","randomId","_a","clamp","n1","n2","n3","min","num","max","a","b","dragObserver","mutationList","observer","mutation","src","target","createDocumentWireframe","elementsListOrSelector","itemLayer","item","element","wire","parent","layer","id","wireId","makeWireframeElementResizable","wireElementOrId","handles","container","keepAspectRatio","rest","handlesToAdd","allSides","allCorners","handleName","setResizableBoxEvents","box","minWidth","minHeight","maxWidth","maxHeight","draggable","invertOnContainerEdge","onStart","onMove","onEnd","shouldKeepAspect","initialAspectRatio","handleElements","rects","handle","event","corner","handleMove","moveBox","handlePointerUp","e","aspectRatio","currentX","currentY","startLeft","startTop","deltaX","deltaY","top","left","width","height","spaceLeft","spaceRight","spaceTop","spaceBottom","newHeight","newWidth","clampedWidth","clampedHeight","widthRatio","heightRatio","finalWidthBasedOnHeight","finalHeightBasedOnWidth","clampedTop","clampedLeft","initResizableBoxes","box1","box2","box3","stage","box4","box5","box6","wire1","wire2","wire4","wire5","wire6"],"mappings":"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"}