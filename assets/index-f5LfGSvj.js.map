{"version":3,"file":"index-f5LfGSvj.js","sources":["../../src/utils.ts","../../src/index.ts","../../demo/main.ts"],"sourcesContent":["const S4 = (): string => (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\nconst randomUUIDDumbPolyfill = (): string => `${S4()}${S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`;\nexport const randomId = (): string => crypto.randomUUID?.() || randomUUIDDumbPolyfill();\n\n/**\n * Limit a number between 2 values, inclusive, order doesn't matter\n * @param {number} n1\n * @param {number} n2\n * @param {number} n3\n * @returns {number}\n */\nexport const clamp = (n1: number, n2: number = n1, n3: number = n2): number => {\n    const [min, num, max] = [n1, n2, n3].sort((a, b) => a - b);\n    return Math.min(max, Math.max(min, num));\n};\n","import type { HandleName, MakeWireframeResizableOptions, Rects, ResizableBoxOptions } from './types';\nimport { clamp, randomId } from './utils';\nexport type * from './types';\n\nconst dragObserver = new MutationObserver((mutationList, observer) => {\n    mutationList.forEach((mutation) => {\n        const src = mutation.target as HTMLElement;\n        if (!src.dataset) return; // Type guard\n        const target = document.getElementById(src.dataset.compId || src.dataset.wireId || '') as HTMLElement | null;\n\n        if (!target) {\n            observer.disconnect();\n            return;\n        }\n\n        target.style.top = src.style.top;\n        target.style.left = src.style.left;\n        target.style.width = src.style.width;\n        target.style.height = src.style.height;\n    });\n});\n\n/**\n * Create wireframes\n * We create a separate wireframe layer for each offset-parent of the collected elements\n * This way we don't need to worry about observing document layout changes (at least theoretically)\n * @param {HTMLElement[] | NodeListOf<HTMLElement> | string} elementsListOrSelector A list of elements or a selector\n * @returns {HTMLElement[]}\n */\nexport function createDocumentWireframe(elementsListOrSelector: HTMLElement[] | NodeListOf<HTMLElement> | string): HTMLElement[] {\n    const itemLayer = document.createElement('div');\n    itemLayer.className = 'wireframe-layer';\n\n    const item = document.createElement('div');\n    item.className = 'wireframe-layer-item';\n\n    const elements: HTMLElement[] = [\n        ...(typeof elementsListOrSelector === 'string'\n            ? (document.querySelectorAll(elementsListOrSelector) as NodeListOf<HTMLElement>) || []\n            : elementsListOrSelector),\n    ];\n\n    const wires = elements.map((element) => {\n        const wire = item.cloneNode() as HTMLElement;\n        const parent = element.parentNode as HTMLElement | null;\n        if (!parent) throw new Error('Element must have a parent node');\n\n        const layer = (parent.querySelector('.wireframe-layer') || itemLayer.cloneNode()) as HTMLElement;\n\n        layer.id = layer.id || `wireframe-layer-${randomId()}`;\n        element.id = element.id || `comp-${randomId()}`;\n\n        const id = element.id;\n        const wireId = `wire-${id}`;\n\n        element.dataset.wireId = wireId;\n\n        element.style.position = 'absolute'; // Ensure positioning context\n        element.style.top = `${element.offsetTop}px`;\n        element.style.left = `${element.offsetLeft}px`;\n        element.style.width = `${element.offsetWidth}px`;\n        element.style.height = `${element.offsetHeight}px`;\n\n        wire.id = wireId;\n        wire.dataset.compId = id;\n\n        wire.style.position = 'absolute'; // Ensure positioning context for wireframe\n        wire.style.top = element.style.top;\n        wire.style.left = element.style.left;\n        wire.style.width = element.style.width;\n        wire.style.height = element.style.height;\n\n        layer.appendChild(wire);\n\n        if (!parent.contains(layer)) {\n            parent.appendChild(layer);\n        }\n\n        dragObserver.observe(element, {\n            attributes: true,\n            attributeFilter: ['style'],\n        });\n\n        dragObserver.observe(wire, {\n            attributes: true,\n            attributeFilter: ['style'],\n        });\n\n        return wire;\n    });\n\n    return wires;\n}\n\n/**\n * Make a wireframe element resizable\n * @param {HTMLElement|string} wireElementOrId the wireframe box to resize\n * @param {MakeWireframeResizableOptions} options\n */\nexport function makeWireframeElementResizable(\n    wireElementOrId: HTMLElement | string,\n    {\n        handles = 'all',\n        container,\n        keepAspectRatio = false,\n        ...rest // Captures ResizableBoxOptions (including draggable)\n    }: MakeWireframeResizableOptions = {}\n): void {\n    const wire = typeof wireElementOrId === 'string' ? document.getElementById(wireElementOrId) : wireElementOrId;\n\n    if (!wire || !(wire instanceof HTMLElement) || !wire.dataset.compId) {\n        throw new Error(`${wireElementOrId} is not a valid wireframe element or ID`);\n    }\n\n    const element = document.getElementById(wire.dataset.compId);\n    if (!element) {\n        throw new Error(`Could not find original element with ID: ${wire.dataset.compId}`);\n    }\n    element.style.position = 'absolute';\n\n    wire.dataset.resizable = 'resizable';\n\n    if (container) {\n        wire.dataset.resizableContainer = container;\n    }\n\n    wire.innerHTML = '';\n\n    let handlesToAdd: HandleName[] = [];\n    const allSides: HandleName[] = ['top', 'right', 'bottom', 'left'];\n    const allCorners: HandleName[] = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\n\n    if (handles === 'all') {\n        handlesToAdd = [...allSides, ...allCorners];\n    } else if (handles === 'sides') {\n        handlesToAdd = [...allSides];\n    } else if (handles === 'corners') {\n        handlesToAdd = [...allCorners];\n    } else if (Array.isArray(handles)) {\n        handlesToAdd = handles;\n    } // 'none' or other invalid string results in no handles\n\n    handlesToAdd.forEach(handleName => {\n        wire.innerHTML += `<div class=\"resizable-box-handle\" data-handle=\"${handleName}\"></div>`;\n    });\n\n    if (keepAspectRatio) {\n        wire.dataset.resizableAspect = 'keep';\n    } else {\n        delete wire.dataset.resizableAspect;\n    }\n\n    setResizableBoxEvents(wire, { keepAspectRatio, ...rest });\n}\n\n/**\n * Sets up pointer events for resizing and dragging a box element.\n * Expects a specific HTML structure with optional handles.\n * @param {HTMLElement} box The element to make resizable/draggable.\n * @param {ResizableBoxOptions} options Configuration options.\n */\nexport function setResizableBoxEvents(\n    box: HTMLElement,\n    {\n        minWidth = 10,\n        minHeight = 10,\n        maxWidth,\n        maxHeight,\n        draggable = true,\n        keepAspectRatio = false,\n        invertOnContainerEdge = false,\n        onStart,\n        onMove,\n        onEnd\n    }: ResizableBoxOptions = {}\n): void {\n    const container = document.getElementById(box.dataset.resizableContainer || '') || document.body;\n\n    if (!draggable) {\n        box.dataset.resizableDraggable = 'false';\n    } else {\n        delete box.dataset.resizableDraggable;\n    }\n\n    if (invertOnContainerEdge) {\n        box.dataset.resizableInvert = 'invert';\n    } else {\n        delete box.dataset.resizableInvert;\n    }\n\n    const shouldKeepAspect = keepAspectRatio || box.dataset.resizableAspect === 'keep';\n    const initialAspectRatio = shouldKeepAspect ? box.offsetWidth / box.offsetHeight : 0;\n\n    maxWidth = maxWidth ?? container.offsetWidth;\n    maxHeight = maxHeight ?? container.offsetHeight;\n\n    const handleElements: HTMLElement[] = [...box.querySelectorAll<HTMLElement>('[data-handle]')];\n    if (draggable) {\n        handleElements.push(box);\n    }\n\n    const parent = box.offsetParent as HTMLElement | null;\n\n    if (!parent || !container.contains(parent)) {\n        console.error('Resizable box must have an offsetParent contained within the specified container or document.body');\n        return;\n    }\n\n    const rects: Rects = {\n        container: {} as DOMRect,\n        parent: {} as DOMRect,\n        initial: { top: 0, left: 0, width: 0, height: 0 },\n        diff: { left: 0, top: 0 },\n        start: { left: 0, top: 0 },\n        min: { width: minWidth, height: minHeight }, // Use provided min values\n        max: { width: maxWidth, height: maxHeight }, // Use resolved max values\n    };\n\n    handleElements.forEach((handle) => {\n        handle.addEventListener(\n            'pointerdown',\n            (event: PointerEvent) => {\n                const target = event.target as HTMLElement;\n                if (!target || !target.dataset) return;\n\n                event.preventDefault();\n                event.stopPropagation();\n\n                // Find the associated component if the box is a wireframe\n                const component = box.dataset.compId ? document.getElementById(box.dataset.compId) : null;\n\n                // Store original z-indices\n                const originalBoxZIndex = box.style.zIndex;\n                const originalComponentZIndex = component ? component.style.zIndex : '';\n\n                rects.container = container.getBoundingClientRect();\n                rects.parent = parent.getBoundingClientRect();\n                rects.initial = {\n                    top: box.offsetTop,\n                    left: box.offsetLeft,\n                    width: box.offsetWidth,\n                    height: box.offsetHeight,\n                };\n                rects.diff = {\n                    left: rects.parent.left - rects.container.left,\n                    top: rects.parent.top - rects.container.top,\n                };\n                rects.start = {\n                    left: event.clientX,\n                    top: event.clientY,\n                };\n\n                const corner = target.dataset.handle || '';\n                const handleMove = moveBox.bind(null, box, corner, rects, onMove, shouldKeepAspect, initialAspectRatio, invertOnContainerEdge);\n\n                container.dataset.draggingWithin = 'true';\n                box.dataset.dragging = 'true';\n                box.style.willChange = 'top, left, width, height';\n                box.style.zIndex = '1000'; // Set high z-index for dragging box (or wireframe)\n                if (component) {\n                    component.style.zIndex = '999'; // Set slightly lower high z-index for component\n                }\n\n                onStart?.(event);\n\n                container.setPointerCapture(event.pointerId);\n                container.addEventListener('pointermove', handleMove);\n\n                const handlePointerUp = (e: PointerEvent) => {\n                    if (e.pointerId !== event.pointerId) return;\n\n                    e.preventDefault();\n                    delete container.dataset.draggingWithin;\n                    delete box.dataset.dragging;\n                    box.style.willChange = 'auto';\n                    box.style.zIndex = originalBoxZIndex; // Restore original box z-index\n                    if (component) {\n                        component.style.zIndex = originalComponentZIndex; // Restore original component z-index\n                    }\n\n                    container.releasePointerCapture(event.pointerId);\n                    container.removeEventListener('pointermove', handleMove);\n                    container.removeEventListener('pointerup', handlePointerUp);\n\n                    onEnd?.(e);\n                };\n\n                container.addEventListener('pointerup', handlePointerUp);\n            },\n            { capture: true }\n        );\n    });\n}\n\nfunction moveBox(\n    box: HTMLElement,\n    corner: string,\n    rects: Rects,\n    onMove: ((e: PointerEvent) => void) | undefined,\n    shouldKeepAspect: boolean,\n    aspectRatio: number,\n    invertOnContainerEdge: boolean,\n    event: PointerEvent\n): void {\n    const currentX = event.clientX;\n    const currentY = event.clientY;\n\n    const startLeft = typeof rects.start.left === 'number' ? rects.start.left : currentX;\n    const startTop = typeof rects.start.top === 'number' ? rects.start.top : currentY;\n    let deltaX = currentX - startLeft;\n    let deltaY = currentY - startTop;\n\n    let { top, left, width, height } = { ...rects.initial };\n\n    event.preventDefault();\n\n    // --- Optional: Clamp Delta based on Container Edges ---\n    if (!invertOnContainerEdge && corner) {\n        const spaceLeft = rects.initial.left + rects.diff.left;\n        const spaceRight = rects.container.width - (rects.initial.left + rects.initial.width + rects.diff.left);\n        const spaceTop = rects.initial.top + rects.diff.top;\n        const spaceBottom = rects.container.height - (rects.initial.top + rects.initial.height + rects.diff.top);\n\n        if (corner.includes('left')) {\n            deltaX = Math.max(deltaX, -spaceLeft);\n        }\n        if (corner.includes('right')) {\n            deltaX = Math.min(deltaX, spaceRight);\n        }\n        if (corner.includes('top')) {\n            deltaY = Math.max(deltaY, -spaceTop);\n        }\n        if (corner.includes('bottom')) {\n            deltaY = Math.min(deltaY, spaceBottom);\n        }\n    }\n    // --- End Delta Clamping ---\n\n    // Calculate new dimensions/position based on the (potentially clamped) delta\n    if (corner.includes('top')) {\n        top = rects.initial.top + deltaY;\n        height = rects.initial.height - deltaY;\n    } else if (corner.includes('bottom')) {\n        height = rects.initial.height + deltaY;\n    }\n\n    if (corner.includes('left')) {\n        left = rects.initial.left + deltaX;\n        width = rects.initial.width - deltaX;\n    } else if (corner.includes('right')) {\n        width = rects.initial.width + deltaX;\n    }\n\n    // Dragging the box itself (no corner)\n    if (!corner) {\n        top = rects.initial.top + deltaY;\n        left = rects.initial.left + deltaX;\n    }\n\n    // --- Aspect Ratio Lock (Basic Implementation) ---\n    // TODO: Refine aspect ratio logic, especially when dragging corners\n    if (shouldKeepAspect && corner) {\n        if (corner.includes('left') || corner.includes('right')) {\n            const newHeight = width / aspectRatio;\n            if (corner.includes('top')) {\n                top -= (newHeight - height);\n            }\n            height = newHeight;\n        } else if (corner.includes('top') || corner.includes('bottom')) {\n            const newWidth = height * aspectRatio;\n             if (corner.includes('left')) {\n                left -= (newWidth - width);\n            }\n            width = newWidth;\n        }\n    }\n    // --- End Aspect Ratio ---\n\n    // --- Final Clamping ---\n    // 1. Clamp dimensions to min/max *options*\n    let clampedWidth = clamp(rects.min.width, rects.max.width, width);\n    let clampedHeight = clamp(rects.min.height, rects.max.height, height);\n\n    // 2. If aspect ratio locked, ensure clamped dimensions still respect it\n    //    (adjust the dimension that changed *less* proportionally)\n    if (shouldKeepAspect && corner) {\n         const widthRatio = clampedWidth / width;\n         const heightRatio = clampedHeight / height;\n\n         if (widthRatio <= heightRatio) {\n             clampedHeight = clampedWidth / aspectRatio;\n         } else {\n             clampedWidth = clampedHeight * aspectRatio;\n         }\n\n         // Re-clamp *both* dimensions after aspect ratio adjustment,\n         // as the secondary adjustment might have pushed the other dimension beyond its limits.\n         clampedWidth = clamp(rects.min.width, rects.max.width, clampedWidth);\n         clampedHeight = clamp(rects.min.height, rects.max.height, clampedHeight);\n\n         // Final check: Ensure the *most* constrained dimension dictates the final size\n         // Recalculate the *other* dimension based on the most recent clamped values.\n         const finalWidthBasedOnHeight = clampedHeight * aspectRatio;\n         const finalHeightBasedOnWidth = clampedWidth / aspectRatio;\n\n         if (clampedWidth < finalWidthBasedOnHeight - 0.001) { // Tolerance for floating point\n             clampedHeight = finalHeightBasedOnWidth;\n         }\n         else {\n              clampedWidth = finalWidthBasedOnHeight;\n         }\n\n         clampedWidth = clamp(rects.min.width, rects.max.width, clampedWidth);\n         clampedHeight = clamp(rects.min.height, rects.max.height, clampedHeight);\n    }\n\n    // 3. Adjust position if dimensions were clamped during resize\n    //    (Ensure the edge opposite the dragged handle stays put)\n    //    Run this *before* clamping position\n    if (corner.includes('top') && clampedHeight !== height) {\n        top = rects.initial.top + rects.initial.height - clampedHeight;\n    }\n    if (corner.includes('left') && clampedWidth !== width) {\n        left = rects.initial.left + rects.initial.width - clampedWidth;\n    }\n     if (!corner) {\n         top = rects.initial.top + deltaY;\n         left = rects.initial.left + deltaX;\n     }\n\n    // 4. Clamp position within the container boundaries *using clamped dimensions*\n    const clampedTop = clamp(\n        -rects.diff.top,\n        rects.container.height - rects.diff.top - clampedHeight,\n        top\n    );\n    const clampedLeft = clamp(\n        -rects.diff.left,\n        rects.container.width - rects.diff.left - clampedWidth,\n        left\n    );\n    // --- End Final Clamping ---\n\n    box.style.top = `${clampedTop}px`;\n    box.style.left = `${clampedLeft}px`;\n    box.style.width = `${clampedWidth}px`;\n    box.style.height = `${clampedHeight}px`;\n\n    onMove?.(event);\n}\n","import { setResizableBoxEvents, createDocumentWireframe, makeWireframeElementResizable } from '@/index';\nimport '@/index.css';\nimport '@/theme.css';\nimport './style.css';\n\n// Renamed original init function\nfunction initResizableBoxes() {\n    const box1 = document.getElementById('box1') as HTMLElement | null;\n    const box2 = document.getElementById('box2') as HTMLElement | null;\n    const box3 = document.getElementById('box3') as HTMLElement | null;\n    const stage = document.getElementById('stage') as HTMLElement | null;\n    const box4 = document.getElementById('box4') as HTMLElement | null;\n    const box5 = document.getElementById('box5') as HTMLElement | null;\n    const box6 = document.getElementById('box6') as HTMLElement | null;\n\n    if (!box1 || !box2 || !box3 || !box4 || !box5 || !box6 || !stage) {\n        console.error(\"Demo elements not found!\");\n        return;\n    }\n\n    const [wire1, wire2, wire4, wire5, wire6] = createDocumentWireframe([box1, box2, box4, box5, box6]);\n\n    makeWireframeElementResizable(wire1, {\n        handles: 'all',\n        draggable: true,\n        onStart: () => console.log('Wire1 Start'),\n        onMove: () => console.log('Wire1 Move'),\n        onEnd: () => console.log('Wire1 End'),\n        invertOnContainerEdge: true,\n    });\n\n    makeWireframeElementResizable(wire2, {\n        container: 'stage',\n        handles: 'corners',\n        draggable: false,\n        invertOnContainerEdge: false,\n        minWidth: 50,\n        minHeight: 50,\n        maxWidth: stage.offsetWidth,\n        maxHeight: stage.offsetHeight,\n    });\n\n    setResizableBoxEvents(box3, {\n        draggable: true,\n        keepAspectRatio: false,\n        minWidth: 100,\n        minHeight: 50,\n        onStart: () => console.log('Box3 Start'),\n        onMove: () => console.log('Box3 Move'),\n        onEnd: () => console.log('Box3 End'),\n    });\n\n    makeWireframeElementResizable(wire4, {\n        container: 'stage',\n        handles: 'none',\n        draggable: true,\n    });\n\n    makeWireframeElementResizable(wire5, {\n        container: 'stage',\n        handles: ['top-left', 'bottom-right'],\n        draggable: false,\n        keepAspectRatio: true,\n        minWidth: 40,\n        minHeight: 40,\n    });\n\n    makeWireframeElementResizable(wire6, {\n        container: 'stage',\n        handles: 'all',\n        draggable: true,\n        invertOnContainerEdge: true,\n    });\n}\n\n/**\n * Run init() after the DOM is fully loaded.\n */\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', initResizableBoxes);\n} else {\n    initResizableBoxes();\n}\n"],"names":["S4","randomUUIDDumbPolyfill","randomId","_a","clamp","n1","n2","n3","min","num","max","a","b","dragObserver","mutationList","observer","mutation","src","target","createDocumentWireframe","elementsListOrSelector","itemLayer","item","element","wire","parent","layer","id","wireId","makeWireframeElementResizable","wireElementOrId","handles","container","keepAspectRatio","rest","handlesToAdd","allSides","allCorners","handleName","setResizableBoxEvents","box","minWidth","minHeight","maxWidth","maxHeight","draggable","invertOnContainerEdge","onStart","onMove","onEnd","shouldKeepAspect","initialAspectRatio","handleElements","rects","handle","event","component","originalBoxZIndex","originalComponentZIndex","corner","handleMove","moveBox","handlePointerUp","e","aspectRatio","currentX","currentY","startLeft","startTop","deltaX","deltaY","top","left","width","height","spaceLeft","spaceRight","spaceTop","spaceBottom","newHeight","newWidth","clampedWidth","clampedHeight","widthRatio","heightRatio","finalWidthBasedOnHeight","finalHeightBasedOnWidth","clampedTop","clampedLeft","initResizableBoxes","box1","box2","box3","stage","box4","box5","box6","wire1","wire2","wire4","wire5","wire6"],"mappings":"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"}